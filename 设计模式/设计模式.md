## 策略模式
定义一个算法族，分别分装起来，让他们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。

## 观察者模式
定义了对象之间一对多依赖，这样一来，当一个对象发生变化时，他的所有依赖对象都会收到通知并更新

## 装饰者模式
动态地将责任附加到对象上

## 工厂方法模式
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类

## 抽象工厂模式
提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指
定具体类。

## 单例模式
确保一个类只有一个实例，并提供一个全局访问点。

## 命令模式
将请求封装的对象，以便使用不同的请求、队列或者日志来参数化其他对象。

## 适配器模式
将一个类的接口转换成用户期望的另一个接口。适配器让原本不兼容的类可以合作无间。

## 外观模式
提供一个简单的接口，来访问子系统中的一群接口。外观顶一个了一个高级接口，让子系统的使用更加容易。

## 模板方法
在一个方法中定义算法的骨架，而将一些步骤的实现推迟到子类中，模板方法使得子类不改变算法结构的情况下重新定义算法。


## 组合模式
允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让用户以一致的方法处理个别对象以及对象组合。

## 状态模式 
允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

